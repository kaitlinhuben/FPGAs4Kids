Elm.Model = Elm.Model || {};
Elm.Model.CircuitFunctions = Elm.Model.CircuitFunctions || {};
Elm.Model.CircuitFunctions.make = function (_elm) {
   "use strict";
   _elm.Model = _elm.Model || {};
   _elm.Model.CircuitFunctions = _elm.Model.CircuitFunctions || {};
   if (_elm.Model.CircuitFunctions.values)
   return _elm.Model.CircuitFunctions.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   _P = _N.Ports.make(_elm),
   $moduleName = "Model.CircuitFunctions",
   $Array = Elm.Array.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Model$Model = Elm.Model.Model.make(_elm);
   var checkSolved = F3(function (circuit,
   solution,
   gatesToCheck) {
      return function () {
         switch (gatesToCheck.ctor)
         {case "::":
            switch (gatesToCheck._1.ctor)
              {case "[]": return function () {
                      var solutionStatus = A2($Maybe.withDefault,
                      true,
                      A2($Dict.get,
                      gatesToCheck._0,
                      solution));
                      var circuitGate = A2($Model$Model.getGate,
                      gatesToCheck._0,
                      circuit);
                      var circuitStatus = circuitGate.status;
                      return _U.eq(circuitStatus,
                      solutionStatus) ? true : false;
                   }();}
              return function () {
                 var solutionStatus = A2($Maybe.withDefault,
                 true,
                 A2($Dict.get,
                 gatesToCheck._0,
                 solution));
                 var circuitGate = A2($Model$Model.getGate,
                 gatesToCheck._0,
                 circuit);
                 var circuitStatus = circuitGate.status;
                 return !_U.eq(circuitStatus,
                 solutionStatus) ? false : A3(checkSolved,
                 circuit,
                 solution,
                 gatesToCheck._1);
              }();
            case "[]": return true;}
         _U.badCase($moduleName,
         "between lines 165 and 187");
      }();
   });
   var checkIfSolved = F2(function (circuit,
   solution) {
      return function () {
         var gatesToCheck = $Dict.keys(solution);
         return A3(checkSolved,
         circuit,
         solution,
         gatesToCheck);
      }();
   });
   var simOutputGate = F2(function (gate,
   state) {
      return function () {
         var inputNames = gate.inputs;
         var inputName = A2($Model$Model.getGateName,
         0,
         inputNames);
         var inputGate = A2($Model$Model.getGate,
         inputName,
         state);
         var inputStatus = inputGate.status;
         return _U.replace([["status"
                            ,inputStatus]],
         gate);
      }();
   });
   var simNotGate = F2(function (gate,
   state) {
      return function () {
         var inputNames = gate.inputs;
         var input1Name = A2($Model$Model.getGateName,
         0,
         inputNames);
         var input1Gate = A2($Model$Model.getGate,
         input1Name,
         state);
         var input1Status = input1Gate.status;
         var logicFunction = gate.logic;
         var result = A2(logicFunction,
         input1Status,
         input1Status);
         return _U.replace([["status"
                            ,result]],
         gate);
      }();
   });
   var simNormalGate = F2(function (gate,
   state) {
      return _U.eq($Array.length(gate.inputs),
      1) ? A2(simNotGate,
      gate,
      state) : function () {
         var inputNames = gate.inputs;
         var input1Name = A2($Model$Model.getGateName,
         0,
         inputNames);
         var input1Gate = A2($Model$Model.getGate,
         input1Name,
         state);
         var input1Status = input1Gate.status;
         var input2Name = A2($Model$Model.getGateName,
         1,
         inputNames);
         var input2Gate = A2($Model$Model.getGate,
         input2Name,
         state);
         var input2Status = input2Gate.status;
         var logicFunction = gate.logic;
         var result = A2(logicFunction,
         input1Status,
         input2Status);
         return _U.replace([["status"
                            ,result]],
         gate);
      }();
   });
   var simGate = F2(function (gate,
   state) {
      return _U.eq(gate.gateType,
      $Model$Model.NormalGate) ? A2(simNormalGate,
      gate,
      state) : _U.eq(gate.gateType,
      $Model$Model.InputGate) ? gate : _U.eq(gate.gateType,
      $Model$Model.OutputGate) ? A2(simOutputGate,
      gate,
      state) : _U.badIf($moduleName,
      "between lines 92 and 94");
   });
   var updateGate = F2(function (gateName,
   state) {
      return function () {
         var stateMinusGate = A2($Dict.remove,
         gateName,
         state);
         var gateToSim = A2($Model$Model.getGate,
         gateName,
         state);
         var simulatedGate = A2(simGate,
         gateToSim,
         state);
         var simGateWithImg = _U.eq(simulatedGate.status,
         true) ? _U.replace([["imgName"
                             ,simulatedGate.imgOnName]],
         simulatedGate) : _U.replace([["imgName"
                                      ,simulatedGate.imgOffName]],
         simulatedGate);
         return A3($Dict.insert,
         simulatedGate.name,
         simGateWithImg,
         stateMinusGate);
      }();
   });
   var updateStateWithInput = F3(function (state,
   name,
   inputStatuses) {
      return function () {
         var stateMinusInput = A2($Dict.remove,
         name,
         state);
         var inputGate = A2($Model$Model.getGate,
         name,
         state);
         var inputStatus = A2($Maybe.withDefault,
         false,
         A2($Dict.get,
         name,
         inputStatuses));
         var updatedInputGate = _U.replace([["status"
                                            ,inputStatus]],
         inputGate);
         return A3($Dict.insert,
         name,
         updatedInputGate,
         stateMinusInput);
      }();
   });
   var updateInputs = F3(function (state,
   inputNames,
   inputStatuses) {
      return function () {
         switch (inputNames.ctor)
         {case "::":
            switch (inputNames._1.ctor)
              {case "[]":
                 return A3(updateStateWithInput,
                   state,
                   inputNames._0,
                   inputStatuses);}
              return function () {
                 var updatedState = A3(updateStateWithInput,
                 state,
                 inputNames._0,
                 inputStatuses);
                 return A3(updateInputs,
                 updatedState,
                 inputNames._1,
                 inputStatuses);
              }();
            case "[]": return state;}
         _U.badCase($moduleName,
         "between lines 40 and 52");
      }();
   });
   var updateGameState = function (gameState) {
      return function () {
         var netNames = gameState.networkNames;
         var inputStatuses = gameState.inputStatuses;
         var inputNames = gameState.inputNames;
         var circuitState = gameState.circuitState;
         var circuitStateUpdatedInputs = A3(updateInputs,
         circuitState,
         inputNames,
         inputStatuses);
         var simulatedCircuitState = A3($List.foldl,
         updateGate,
         circuitStateUpdatedInputs,
         netNames);
         var levelSolved = A2(checkIfSolved,
         simulatedCircuitState,
         gameState.solution);
         return _U.replace([["circuitState"
                            ,simulatedCircuitState]
                           ,["completed",levelSolved]],
         gameState);
      }();
   };
   _elm.Model.CircuitFunctions.values = {_op: _op
                                        ,updateGameState: updateGameState
                                        ,updateInputs: updateInputs
                                        ,updateStateWithInput: updateStateWithInput
                                        ,updateGate: updateGate
                                        ,simGate: simGate
                                        ,simNormalGate: simNormalGate
                                        ,simNotGate: simNotGate
                                        ,simOutputGate: simOutputGate
                                        ,checkIfSolved: checkIfSolved
                                        ,checkSolved: checkSolved};
   return _elm.Model.CircuitFunctions.values;
};